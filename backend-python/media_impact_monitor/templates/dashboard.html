{% extends 'base.html' %} {% block content %}

<div class="chart-container">
  <div id="time-range-selector"></div>
  <div class="timeline-chart"></div>
  <div class="timeline-legend"></div>
</div>

<style>
  .chart-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 100%;
    max-width: 1000px;
    margin: 0 auto;
  }

  .timeline-chart {
    width: 100%;
    height: 500px;
  }

  .timeline-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    padding: 10px;
    background: #fff;
    border-top: 1px solid #eee;
    margin-top: 20px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 150px;
  }

  .legend-color {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  .event-bar {
    fill-opacity: 0.8;
    stroke: white;
    stroke-width: 1;
    cursor: pointer;
    transition: fill-opacity 0.2s;
    rx: 4;
    ry: 4;
  }

  .event-bar:hover {
    fill-opacity: 1;
  }

  .tooltip {
    position: absolute;
    padding: 10px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    pointer-events: none;
    font-size: 14px;
  }

  .brush-container {
    width: 100%;
    height: 60px;
    margin-bottom: 20px;
  }

  .brush-area {
    fill: #f0f0f0;
  }

  .selection {
    fill: #e2e2e2;
    stroke: #888;
    stroke-width: 1px;
  }

  .handle {
    fill: #666;
    cursor: ew-resize;
  }
</style>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  // Make Django template variables available to JavaScript
  const events = {{ events|safe }};
  const organizations = {
    'Fridays for Future': '#4CAF50',
    'Last Generation': '#FF5722',
    'Extinction Rebellion': '#9C27B0',
    'BUND': '#2196F3',
    'Greenpeace': '#009688',
    'Other': '#607D8B'
  };
  const color = organizationName => (organizations[organizationName] || organizations['Other']);

  // Define margins at the top level
  const margin = {top: 20, right: 20, bottom: 30, left: 40};
  const width = 960 - margin.left - margin.right;
  const height = 500 - margin.top - margin.bottom;

  // Helper function to determine aggregation unit
  function determineAggregationUnit(timeRange, width) {
    const daysInRange = (timeRange[1] - timeRange[0]) / (1000 * 60 * 60 * 24);
    const fittableColumns = Math.floor(width / 10); // minimum 10px per column
    
    if (daysInRange <= fittableColumns) return 'day';
    if (daysInRange <= fittableColumns * 3) return 'week'; // should be 7
    return 'month';
  }

  // Helper function to aggregate events
  function aggregateEventsByPeriod(events, aggregationUnit) {
    const grouped = d3.group(events, d => {
      const date = new Date(d.date);
      switch(aggregationUnit) {
        case 'week':
          return d3.timeWeek.floor(date);
        case 'month':
          return d3.timeMonth.floor(date);
        default:
          return date;
      }
    });
    
    return Array.from(grouped, ([date, events]) => {
      const organizerSizes = {};
      let totalSize = 0;
      
      // Initialize all organizations with 0
      Object.keys(organizations).forEach(org => {
        organizerSizes[org] = 0;
      });
      
      events.forEach(event => {
        // Ensure we have valid numbers and prevent division by zero
        const eventSize = Math.max(0, Number(event.size_number) || 0);
        const organizerCount = Math.max(1, event.organizers?.length || 1);
        const sizePerOrganizer = eventSize / organizerCount;
        
        // Handle events with no organizers
        const eventOrganizers = (event.organizers?.length ? event.organizers : ['Other']);
        
        eventOrganizers.forEach(org => {
          organizerSizes[org] = (organizerSizes[org] || 0) + sizePerOrganizer;
        });
        totalSize += eventSize; // Add the full event size to total
      });

      // Get the number of days in the period
      const daysInPeriod = (() => {
        const dateObj = new Date(date);
        switch(aggregationUnit) {
          case 'week':
            return 7;
          case 'month':
            // Get actual days in this specific month
            return new Date(
              dateObj.getFullYear(),
              dateObj.getMonth() + 1,
              0
            ).getDate();
          default:
            return 1;
        }
      })();

      // Only divide by days if the value is not zero
      Object.keys(organizerSizes).forEach(org => {
        organizerSizes[org] = daysInPeriod > 0 ? 
          organizerSizes[org] / daysInPeriod : 0;
      });
      totalSize = daysInPeriod > 0 ? totalSize / daysInPeriod : 0;
      
      return {
        date,
        totalSize,
        organizerSizes,
        events
      };
    });
  }

  // Create SVG container
  const svg = d3.select('.timeline-chart')
    .append('svg')
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append('g')
    .attr('transform', `translate(${margin.left},${margin.top})`);

  // Define scales
  const xScale = d3.scaleTime()
    .range([0, width]);

  const yScale = d3.scaleLinear()
    .range([height, 0]);

  const brushXScale = d3.scaleTime()
    .domain(d3.extent(events, d => new Date(d.date)))
    .range([0, width]);

  const sizeScale = d3.scaleLinear()
    .domain([0, d3.max(events, d => d.size_number || 0)])
    .range([5, 200]);

  // Axis formatting
  function getAxisFormat(aggregationUnit) {
    switch(aggregationUnit) {
      case 'week':
        return d3.timeFormat('%d %b');
      case 'month':
        return d3.timeFormat('%b %Y');
      default:
        return d3.timeFormat('%d %b');
    }
  }

  function updateAxis(aggregationUnit) {
    const format = getAxisFormat(aggregationUnit);
    const xAxis = d3.axisBottom(xScale)
      .tickFormat(format);

    switch(aggregationUnit) {
      case 'week':
        xAxis.ticks(d3.timeWeek.every(1));
        break;
      case 'month':
        xAxis.ticks(d3.timeMonth.every(1));
        break;
      default:
        xAxis.ticks(d3.timeDay.every(1));
    }

    svg.select('.x-axis')
      .transition()
      .duration(750)
      .call(xAxis);
  }

  // Tooltip handlers
  function showDailyTooltip(event, d) {
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'tooltip')
      .style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY - 10) + 'px');

    tooltip.html(`
      <strong>${d.organizers.join(', ')}</strong><br/>
      ${d.date}<br/>
      ${d.city}<br/>
      ${d.description}<br/>
      ${d.size_number || '?'} participants
    `);
  }

  function showAggregatedTooltip(event, d) {
    const tooltip = d3.select('body')
      .append('div')
      .attr('class', 'tooltip')
      .style('left', (event.pageX + 10) + 'px')
      .style('top', (event.pageY - 10) + 'px');

    const date = new Date(d.data.date);
    const format = getAxisFormat(determineAggregationUnit(xScale.domain(), width));
    
    tooltip.html(`
      <strong>${format(date)}</strong><br/>
      ${Object.entries(d.data.organizerSizes)
        .map(([org, size]) => `${org}: ${Math.round(size)} participants`)
        .join('<br/>')}
      <br/>
      Total: ${Math.round(d.data.totalSize)} participants
    `);
  }

  function hideTooltip() {
    d3.selectAll('.tooltip').remove();
  }

  // View update functions
  function updateDailyView(events) {
    const barWidth = Math.min(16, Math.max(4, width / events.length - 2));
    
    const bars = svg.selectAll('.event-bar-group')
      .data(events);

    bars.exit().remove();

    const newBars = bars.enter()
      .append('g')
      .attr('class', 'event-bar-group');

    const allBars = bars.merge(newBars)
      .attr('transform', (d, i, nodes) => {
        const date = new Date(d.date);
        const prevBars = events
          .slice(0, events.indexOf(d))
          .filter(prev => new Date(prev.date).getTime() === date.getTime());
        const totalHeight = prevBars.reduce((sum, prev) => sum + sizeScale(prev.size_number || 0), 0);
        return `translate(${xScale(date) - barWidth/2}, ${height - totalHeight - sizeScale(d.size_number || 0)})`;
      })
      .on('mouseover', showDailyTooltip)
      .on('mouseout', hideTooltip);

    allBars.each(function(d) {
      const group = d3.select(this);
      const totalHeight = sizeScale(d.size_number || 0);
      const organizers = d.organizers && d.organizers.length > 0 ? d.organizers : ['Other'];
      const segmentHeight = totalHeight / organizers.length;

      group.selectAll('*').remove();

      const segments = group.selectAll('.event-segment')
        .data(organizers);

      segments.exit().remove();

      segments.enter()
        .append('rect')
        .attr('class', 'event-segment')
        .merge(segments)
        .attr('x', 0)
        .attr('y', (_, i) => i * segmentHeight)
        .attr('width', barWidth)
        .attr('height', segmentHeight)
        .attr('fill', org => color(org))
        .attr('fill-opacity', 0.8);

      group.append('rect')
        .attr('width', barWidth)
        .attr('height', totalHeight)
        .attr('fill', 'none')
        .attr('stroke', 'white')
        .attr('stroke-width', 0.5);
    });
  }

  function updateAggregatedView(aggregatedData, aggregationUnit) {
    // Add console logging for debugging
    console.log('Aggregated Data:', aggregatedData);
    
    const stack = d3.stack()
      .keys(Object.keys(organizations))
      .value((d, key) => {
        // Ensure we return a valid number
        const value = d.organizerSizes[key] || 0;
        return isNaN(value) ? 0 : value;
      })
      .order(d3.stackOrder);

    const stackedData = stack(aggregatedData);
    
    // Add console logging for debugging
    console.log('Stacked Data:', stackedData);

    const barGroups = svg.selectAll('.stacked-bar-group')
      .data(stackedData);

    barGroups.exit().remove();

    const newBarGroups = barGroups.enter()
      .append('g')
      .attr('class', 'stacked-bar-group')
      .attr('fill', d => color(d.key));

    const allBarGroups = barGroups.merge(newBarGroups);

    const barWidth = Math.min(
      aggregationUnit === 'week' ? 30 : 50,
      width / aggregatedData.length - 2
    );

    allBarGroups.selectAll('rect')
      .data(d => d)
      .join('rect')
      .attr('x', d => xScale(new Date(d.data.date)) - barWidth/2)
      .attr('y', d => yScale(d[1]))
      .attr('height', d => yScale(d[0]) - yScale(d[1]))
      .attr('width', barWidth)
      .attr('rx', 4)
      .attr('ry', 4)
      .on('mouseover', showAggregatedTooltip)
      .on('mouseout', hideTooltip);
  }

  // Main visualization update function
  function updateVisualization(filteredEvents) {
    const aggregationUnit = determineAggregationUnit(xScale.domain(), width);
    const processedData = aggregationUnit === 'day' 
        ? filteredEvents 
        : aggregateEventsByPeriod(filteredEvents, aggregationUnit);

    // Update x scale
    xScale.domain(d3.extent(processedData, d => new Date(d.date)));
    
    // Update y scale based on view type
    if (aggregationUnit === 'day') {
        yScale.domain([0, d3.max(processedData, d => d.size_number || 0)]);
    } else {
        const stack = d3.stack()
            .keys(Object.keys(organizations))
            .value((d, key) => d.organizerSizes[key] || 0);
        const stackedData = stack(processedData);
        const maxHeight = d3.max(stackedData, layer => d3.max(layer, d => d[1]));
        yScale.domain([0, maxHeight || 0]);
    }

    // Clear all existing elements
    svg.selectAll('.event-bar-group').remove();
    svg.selectAll('.stacked-bar-group').remove();
    
    if (aggregationUnit === 'day') {
        updateDailyView(processedData);
    } else {
        updateAggregatedView(processedData, aggregationUnit);
    }

    updateAxis(aggregationUnit);
  }

  // Brush handler
  function brushed(event) {
    if (event.selection) {
      const [x0, x1] = event.selection.map(brushXScale.invert);
      xScale.domain([x0, x1]);

      const eventsInRange = events.filter(d => {
        const date = new Date(d.date);
        return date >= x0 && date <= x1;
      });

      updateVisualization(eventsInRange);
    }
  }

  // Initial setup
  svg.append('g')
    .attr('class', 'x-axis')
    .attr('transform', `translate(0,${height})`);

  // Create brush chart
  function createBrushChart() {
    const brushHeight = 50;
    const brushMargin = {top: 5, right: margin.right, bottom: 5, left: margin.left};
    const brushWidth = width + margin.left + margin.right;

    const brushSvg = d3.select('#time-range-selector')
      .append('svg')
      .attr('width', brushWidth)
      .attr('height', brushHeight)
      .append('g')
      .attr('transform', `translate(${brushMargin.left},${brushMargin.top})`);

    const brushYScale = d3.scaleLinear()
      .domain([0, d3.max(events, d => d.size_number || 0)])
      .range([brushHeight - brushMargin.top - brushMargin.bottom, 0]);

    brushSvg.selectAll('.mini-bar')
      .data(events)
      .enter()
      .append('rect')
      .attr('class', 'mini-bar')
      .attr('x', d => brushXScale(new Date(d.date)) - 2)
      .attr('y', d => brushYScale(d.size_number || 0))
      .attr('width', 4)
      .attr('height', d => brushHeight - brushMargin.top - brushMargin.bottom - brushYScale(d.size_number || 0))
      .attr('fill', '#ccc');

    const brush = d3.brushX()
      .extent([[0, 0], [width, brushHeight - brushMargin.top - brushMargin.bottom]])
      .on('brush end', brushed);

    brushSvg.append('g')
      .attr('class', 'brush')
      .call(brush)
      .call(brush.move, brushXScale.range());
  }

  // Initial visualization
  updateVisualization(events);
  createBrushChart();
</script>
{% endblock %}
